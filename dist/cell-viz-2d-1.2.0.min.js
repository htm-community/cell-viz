/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(2);
	module.exports = __webpack_require__(3);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	let DEFAULT_SPARSITY = 0.02;

	/***** Private TOOLS *****/

	// a tool to loop x times
	const times = x => f => {
	    if (x > 0) {
	        f()
	        times (x - 1) (f)
	    }
	}

	function getRandomInt(min, max) {
	    return Math.floor(Math.random() * (max - min)) + min;
	}

	function flip(bit) {
	    if (bit === 0) return 1;
	    return 0;
	}

	function overflowSafeUniqueness(n, w) {
	    let bigN = math.bignumber(n);
	    let bigW = math.bignumber(w);

	    let nf = math.factorial(bigN);
	    let wf = math.factorial(bigW);
	    let nwf = math.factorial(math.subtract(bigN, bigW));

	    return math.divide(nf, math.multiply(wf, nwf));
	}

	function closeEnoughSparsity(a, b) {
	    let diff = Math.abs(a - b)
	    // Close enough if within one percent.
	    return diff <= 0.01
	}

	/***** PUBLIC functions start here *****/


	/*********
	 CREATE
	*********/

	function getRandom(n, w) {
	    let out = []
	    let randomIndex
	    let sparsity

	    if (w === undefined) {
	        w = n * DEFAULT_SPARSITY
	    }

	    sparsity = w / n

	    // Fill array with zeros.
	    while(out.length < n) {
	        out.push(0)
	    }
	    // If not sparse enough, randomly flip 0 bits to 1.
	    while (population(out) / n < sparsity) {
	        // Make a random 0 bit into a 1.
	        randomIndex = getRandomInt(0, n)
	        if (out[randomIndex] === 0) {
	            out[randomIndex] = 1
	        }
	    }

	    return out;
	}

	function getEmpty(n) {
	    let out = []

	    times(n, function() {
	        out.push(0)
	    })
	    return out
	}

	/*********
	 INSPECT
	 *********/

	function getActiveBits(sdr) {
	    let active = []
	    sdr.forEach((bit, i) => {
	        if (bit === 1) active.push(i)
	    })
	    return active
	}

	function getInactiveBits(sdr) {
	    let inactive = [];
	    sdr.forEach((bit, i) => {
	        if (bit === 0) inactive.push(i)
	    })
	    return inactive;
	}

	function population(sdr) {
	    return sdr.reduce(function(sum, n) {
	        return sum + n
	    }, 0)
	}

	function sparsity(sdr) {
	    let onBits = sdr.filter((bit) => {
	        return bit === 1
	    }).length
	    return onBits / sdr.length
	}
	let density = sparsity


	/*********
	 UPDATE
	 *********/

	// Flips every bit.
	function invert(sdr) {
	    return sdr.map((bit) => {
	        if (bit === 0) return 1;
	        return 0;
	    });
	}

	function adjustTo(sdr, targetDensity) {
	    let out = sdr.slice()

	    let n = sdr.length
	    let currentDensity = density(sdr)
	    let diff = targetDensity - currentDensity
	    let diffBits = Math.abs(parseInt(diff * n))
	    let onBits = getActiveBits(sdr)
	    let offBits = getInactiveBits(sdr)


	    // adjust by turning bits on
	    let bitType = 1
	    let targetIndices = offBits
	    // adjust by turning bits off
	    if (targetDensity < currentDensity) {
	        bitType = 0
	        targetIndices = onBits
	    }

	    for (let i = 0; i < diffBits; i++) {
	        let toFlip = targetIndices.splice(getRandomInt(0, targetIndices.length - 1), 1)[0]
	        out[toFlip] = bitType
	    }

	    return out
	}

	// Adds a percent noise by turning on X percent of the off bits and
	// turning off X percent of the on bits.
	function addNoise(sdr, percentNoise) {
	    // The noiseLevel will be the number of total bits to flip.
	    let noiseLevel = Math.floor(population(sdr) * percentNoise);
	    return this.addBitNoise(sdr, noiseLevel)
	}

	function addBitNoise(sdr, noisyBits) {
	    let noisy = []
	    let activeBits = getActiveBits(sdr)
	    let inactiveBits = getInactiveBits(sdr)
	    let toFlip = []
	    // Populate the indices of the bits we want to flip with noise.
	    times(noisyBits, function() {
	        toFlip.push(
	            activeBits.splice(Math.random(activeBits.length - 1), 1)[0]
	        )
	        toFlip.push(
	            inactiveBits.splice(Math.random(inactiveBits.length - 1), 1)[0]
	        )
	    })
	    // Flip them bits into a new array output.
	    sdr.forEach((bit, i) => {
	        let newBit = bit
	        if (toFlip.indexOf(i) >= 0) {
	            newBit = flip(bit)
	        }
	        noisy.push(newBit)
	    })
	    return noisy
	}


	module.exports = {
	    getRandom: getRandom,
	    getEmpty: getEmpty,
	    getActiveBits: getActiveBits,
	    getInactiveBits: getInactiveBits,
	    population: population,
	    sparsity: sparsity,
	    density: density,
	    invert: invert,
	    addNoise: addNoise,
	    addBitNoise: addBitNoise,
	    adjustTo: adjustTo,
	}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	let SdrUtils = __webpack_require__(1)

	let defaultOpts = {
	    width: 400,
	    height: 400,
	    cellSize: 10,
	    rowLength: 100,
	}

	function SdrDrawing(bits, element) {
	    this.bits = bits
	    this.el = element
	}

	SdrDrawing.prototype.draw = function(options) {
	    let sdrId = this.el
	    let opts = Object.assign(defaultOpts, options)
	    let svg = d3.select('#' + this.el)
	        .attr('width', opts.width)
	        .attr('height', opts.height)

	    function treatCells(cells) {
	        cells.attr('id', (d, i) => {
	                return sdrId + '-' + i
	            })
	            .attr('fill', (d) => {
	                if (d === 1) return 'steelblue'
	                return 'white'
	            })
	            .attr('stroke', 'darkgrey')
	            .attr('stroke-width', 0.5)
	            .attr('fill-opacity', 1)
	            .attr('x', function(d, i) {
	                let offset = i % opts.rowLength;
	                return offset * opts.cellSize;
	            })
	            .attr('y', function(d, i) {
	                let offset = Math.floor(i / opts.rowLength);
	                return offset * opts.cellSize;
	            })
	            .attr('width', opts.cellSize)
	            .attr('height', opts.cellSize)
	    }

	    // Update
	    let rectCells = svg.selectAll('rect').data(this.bits)
	    treatCells(rectCells)

	    // Enter
	    let newRectCells = rectCells.enter().append('rect')
	    treatCells(newRectCells)

	    // Exit
	    rectCells.exit().remove()

	    // if (! opts) opts = {};
	    // let sdr = this.bits
	    // let elId = this.el
	    // var title = opts.title || 'SDR';
	    // var color = opts.color || 'steelblue';
	    // var size = (opts.size || POINT_SIZE);
	    // var line = opts.line;
	    // var staticSize = opts.staticSize;
	    // var spartan = opts.spartan || false;
	    // var stretch = opts.stretch;
	    // var population = SdrUtils.population(sdr);
	    // var sparsity = SdrUtils.sparsity(sdr);
	    // var $container = $('#' + elId);
	    // var rowLength = Math.floor(Math.sqrt(sdr.length));
	    // var heightMultiplyer = stretch ? stretch : 1;
	    // var width = undefined;
	    // var height = undefined;
	    // var cssClass = opts.cssClass || '';
	    // var maxWidth = opts.maxWidth;
	    // var slide = false;
	    // var $svg;
	    // var svgId = elId + '-svg';
	    // var svgMarkup = undefined;
	    // var svgDisplay = '';
	    //
	    // if (opts.slide) {
	    //     slide = true;
	    // }
	    // if (line) {
	    //     rowLength = sdr.length;
	    // } else if (! staticSize && size > size * 15 / rowLength) {
	    //     size = size * 15 / rowLength;
	    // }
	    //
	    // // Decrease size of boxes if maxWidth is set and we are overflowing it.
	    // if (maxWidth && size * sdr.length > maxWidth) {
	    //     size = Math.floor(maxWidth / sdr.length);
	    // }
	    //
	    // width = rowLength * size;
	    // height = Math.floor(sdr.length / rowLength) * size;
	    //
	    // if (slide) {
	    //     svgDisplay = 'display="none"';
	    // }
	    //
	    // svgMarkup = '<svg id="' + svgId
	    //     + '" width="' + width
	    //     + '" height="' + (size * heightMultiplyer)
	    //     + '" class="' + cssClass + '" '
	    //     + svgDisplay + '>';
	    //
	    // $svg = $(svgMarkup);
	    //
	    // // Clear out container.
	    // $container.html('');
	    //
	    // if (spartan === false) {
	    //     $container.append(propsTmpl({
	    //         title: title,
	    //         props: [{
	    //             label: 'n', data: sdr.length
	    //         }, {
	    //             label: 'w', data: population
	    //         }, {
	    //             label: 'sparsity', data: sparsity.toFixed(3)
	    //         }]
	    //     }));
	    // } else if (spartan == 'min') {
	    //     $container.append(propsTmpl({
	    //         props: [{
	    //             label: 'n', data: sdr.length
	    //         }, {
	    //             label: 'w', data: population
	    //         }]
	    //     }));
	    // }
	    //
	    // $container.append($svg);
	    // $container.css({
	    //     height: (size * heightMultiplyer * (sdr.length / rowLength)) + 'px'
	    // });
	    //
	    // d3.select('#' + svgId)
	    //     .selectAll('rect')
	    //     .data(sdr)
	    //     .enter()
	    //     .append('rect')
	    //     .attr('x', function(d, i) {
	    //         var offset = i % rowLength;
	    //         return offset * size;
	    //     })
	    //     .attr('y', function(d, i) {
	    //         var offset = Math.floor(i / rowLength);
	    //         return offset * size;
	    //     })
	    //     .attr('index', function(d, i) { return i; })
	    //     .attr('width', size)
	    //     .attr('height', size * heightMultiplyer - 1)
	    //     .attr('class', function(d) {
	    //         if (d == 1) return 'on';
	    //         return 'off';
	    //     });
	    // if (slide) $svg.slideDown(100);

	}

	module.exports = SdrDrawing


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	# ----------------------------------------------------------------------
	# Copyright (C) 2016, Numenta, Inc.  Unless you have an agreement
	# with Numenta, Inc., for a separate license for this software code, the
	# following terms and conditions apply:
	#
	# This program is free software: you can redistribute it and/or modify
	# it under the terms of the GNU Affero Public License version 3 as
	# published by the Free Software Foundation.
	#
	# This program is distributed in the hope that it will be useful,
	# but WITHOUT ANY WARRANTY; without even the implied warranty of
	# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	# See the GNU Affero Public License for more details.
	#
	# You should have received a copy of the GNU Affero Public License
	# along with this program.  If not, see http://www.gnu.org/licenses.
	#
	# http://numenta.org/licenses/
	# ----------------------------------------------------------------------
	*/

	window.SdrUtils = __webpack_require__(1);
	window.SdrDrawing = __webpack_require__(2);


/***/ })
/******/ ]);